// Copyright (c) 2023 Coinstr
// Distributed under the MIT software license

namespace coinstr_sdk {
    void init_logger(LogLevel level);
    [Throws=FFIError]
    sequence<string> get_keychains_list(string base_path, Network network);
};

[Error]
interface FFIError {
    Generic(string err);
};

enum LogLevel {
    "Error",
    "Warn",
    "Info",
    "Debug",
    "Trace",
};

enum RelayStatus {
    "Initialized",
    "Connected",
    "Connecting",
    "Disconnected",
    "Stopped",
    "Terminated",
};

interface Relay {
    string url();
    RelayStatus status();
    boolean is_connected();
};

enum Network {
    "Bitcoin",
    "Testnet",
    "Signet",
    "Regtest",
};

enum WordCount {
    "W12",
    "W18",
    "W24",
};

interface OutPoint {
    string txid();
    u32 vout();
};

interface Utxo {
    OutPoint outpoint();
    u64 value();
    boolean is_spent();
};

interface Balance {
    u64 get_spendable();
    u64 get_total();
};

interface TransactionDetails {
  u64? fee();
  u64 received();
  u64 sent();
  string txid();
  BlockTime? confirmation_time();
};

interface BlockTime {
  u32 height();
  u64 timestamp();
};

interface KeychainSeed {
    string mnemonic();
    string? passphrase();
};

interface Keys {
    string public_key();
    [Throws=FFIError]
    string public_key_bech32();
    [Throws=FFIError]
    string secret_key();
    [Throws=FFIError]
    string secret_key_bech32();
};

interface Metadata {
    string? name();
    string? display_name();
    string? nip05();
};

interface Policy {
    string name();
    string description();
    string descriptor();
};

enum SignerType {
    "Seed",
    "Hardware",
    "AirGap",
};

interface Signer {
    string name();
    string fingerprint();
    string descriptor();
    SignerType signer_type();
    string display();
};

interface Amount {
    [Name=custom]
    constructor(u64 amount);
    [Name=max]
    constructor();
};

[Enum]
interface Proposal {
  Spending(string descriptor, string to_address, u64 amount, string description, string psbt);
  ProofOfReserve(string descriptor, string message, string psbt);
};

[Enum]
interface ApprovedProposal {
  Spending(string psbt);
  ProofOfReserve(string psbt);
};

[Enum]
interface CompletedProposal {
  Spending(string txid, string description);
  ProofOfReserve(string descriptor, string message, string psbt);
};

interface Approval {
    string public_key();
    u64 timestamp();
};

interface Coinstr {
    [Throws=FFIError, Name=open]
    constructor(string base_path, string name, string password, Network network);
    [Throws=FFIError, Name=generate]
    constructor(string base_path, string name, string password, WordCount word_count, string? passphrase, Network network);
    [Throws=FFIError, Name=restore]
    constructor(string base_path, string name, string password, string mnemonic, string? passphrase, Network network);

    string? name();
    [Throws=FFIError]
    void save();
    boolean check_password(string password);
    [Throws=FFIError]
    void rename(string new_name);
    [Throws=FFIError]
    void change_password(string new_password);
    [Throws=FFIError]
    void wipe(string password);
    [Throws=FFIError]
    void clear_cache();

    KeychainSeed seed();
    Keys keys();

    Network network();

    [Throws=FFIError]
    void add_relay(string url);
    sequence<Relay> relays();
    sequence<string> default_relays();
    [Throws=FFIError]
    void remove_relay(string url);
    [Throws=FFIError]
    void shutdown();
    [Throws=FFIError]
    void set_electrum_endpoint(string endpoint);
    [Throws=FFIError]
    string electrum_endpoint();
    u32 block_height();

    [Throws=FFIError]
    void set_metadata(string json);
    [Throws=FFIError]
    Metadata get_profile();
    [Throws=FFIError]
    record<DOMString, Metadata> get_contacts();
    [Throws=FFIError]
    void add_contact(string public_key);
    [Throws=FFIError]
    void remove_contact(string public_key);

    [Throws=FFIError]
    Policy get_policy_by_id(string policy_id);  
    [Throws=FFIError]
    Proposal get_proposal_by_id(string proposal_id);  
    [Throws=FFIError]
    CompletedProposal get_completed_proposal_by_id(string completed_proposal_id);
    [Throws=FFIError]
    Signer get_signer_by_id(string signer_id); 

    [Throws=FFIError]
    void delete_policy_by_id(string policy_id);  
    [Throws=FFIError]
    void delete_proposal_by_id(string proposal_id);  
    [Throws=FFIError]
    void delete_completed_proposal_by_id(string completed_proposal_id);
    [Throws=FFIError]
    void delete_signer_by_id(string signer_id); 

    [Throws=FFIError]
    record<DOMString, Policy> get_policies();
    [Throws=FFIError]
    record<DOMString, Proposal> get_proposals();
    [Throws=FFIError]
    boolean is_proposal_signed(string proposal_id);
    [Throws=FFIError]
    record<DOMString, Approval> get_approvals_by_proposal_id(string proposal_id);
    [Throws=FFIError]
    record<DOMString, CompletedProposal> get_completed_proposals();

    [Throws=FFIError]
    string save_policy(string name, string description, string descriptor, sequence<string> public_keys);
    [Throws=FFIError]
    string spend(string policy_id, string to_address, Amount amount, string description, u16 target_blocks);
    [Throws=FFIError]
    string self_transfer(string from_policy_id, string to_policy_id, Amount amount, u16 target_blocks);   
    [Throws=FFIError]
    string approve(string proposal_id);
    [Throws=FFIError]
    string approve_with_signed_psbt(string proposal_id, string signed_psbt);
    [Throws=FFIError]
    void revoke_approval(string approval_id);
    [Throws=FFIError]
    CompletedProposal finalize(string proposal_id);
    [Throws=FFIError]
    string new_proof_proposal(string policy_id, string message);

    [Throws=FFIError]
    boolean coinstr_signer_exists();
    [Throws=FFIError]
    string save_coinstr_signer();

    [Throws=FFIError]
    void rebroadcast_all_events();
    [Throws=FFIError]
    void republish_shared_key_for_policy(string policy_id);

    [Throws=FFIError]
    Balance? get_balance(string policy_id);
    [Throws=FFIError]
    sequence<TransactionDetails> get_txs(string policy_id);
    [Throws=FFIError]
    sequence<Utxo> get_utxos(string policy_id);
    [Throws=FFIError]
    Balance get_total_balance();
    [Throws=FFIError]
    sequence<TransactionDetails> get_all_txs();
    [Throws=FFIError]
    TransactionDetails? get_tx(string txid);
    [Throws=FFIError]
    string? get_last_unused_address(string policy_id);

    [Throws=FFIError]
    void approve_nostr_connect_request(string event_id);
};
