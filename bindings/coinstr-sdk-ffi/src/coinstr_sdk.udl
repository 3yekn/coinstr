// Copyright (c) 2023 Coinstr
// Distributed under the MIT software license

namespace coinstr_sdk {
    [Throws=FFIError]
    void init_logger(string base_path, Network network);
    [Throws=FFIError]
    sequence<string> get_keychains_list(string base_path, Network network);
};

[Error]
interface FFIError {
    Generic(string err);
};

interface AbortHandle {
    void abort();
    boolean is_aborted();
};

// Nostr FFI

interface Timestamp {
    [Name=now]
    constructor();
    [Name=from_secs]
    constructor(u64 secs);
    u64 as_secs();
    string to_human_datetime();
};

interface SecretKey {
    [Throws=FFIError, Name=from_hex]
    constructor(string hex);
    [Throws=FFIError, Name=from_bech32]
    constructor(string pk);
    string to_hex();
    [Throws=FFIError]
    string to_bech32();
};

interface PublicKey {
    [Throws=FFIError, Name=from_hex]
    constructor(string hex);
    [Throws=FFIError, Name=from_bech32]
    constructor(string pk);
    [Throws=FFIError, Name=from_nostr_uri]
    constructor(string uri);
    string to_hex();
    [Throws=FFIError]
    string to_bech32();
    [Throws=FFIError]
    string to_nostr_uri();
};

interface Keys {
    constructor(SecretKey sk);
    [Name=from_public_key]
    constructor(PublicKey pk);
    [Throws=FFIError, Name=from_sk_str]
    constructor(string sk);
    [Throws=FFIError, Name=from_pk_str]
    constructor(string pk);
    [Name=generate]
    constructor();
    [Throws=FFIError, Name=vanity]
    constructor(sequence<string> prefixes, boolean bech32, u8 num_cores);
    [Throws=FFIError, Name=from_mnemonic]
    constructor(string mnemonic, optional string? passphrase = null);
    PublicKey public_key();
    [Throws=FFIError]
    SecretKey secret_key();
};

interface EventId {
    [Throws=FFIError]
    constructor(PublicKey pubkey, Timestamp created_at, u64 kind, sequence<sequence<string>> tags, string content);
    [Throws=FFIError, Name=from_slice]
    constructor(sequence<u8> bytes);
    [Throws=FFIError, Name=from_hex]
    constructor(string hex);
    [Throws=FFIError, Name=from_bech32]
    constructor(string id);
    [Throws=FFIError, Name=from_nostr_uri]
    constructor(string uri);
    sequence<u8> as_bytes();
    string to_hex();
    [Throws=FFIError]
    string to_bech32();
    [Throws=FFIError]
    string to_nostr_uri();
};

interface Metadata {
    string? name();
    string? display_name();
    string? about();
    string? website();
    string? picture();
    string? banner();
    string? nip05();
    string? lud06();
    string? lud16();
};

enum RelayStatus {
    "Initialized",
    "Connected",
    "Connecting",
    "Disconnected",
    "Stopped",
    "Terminated",
};

interface Relay {
    string url();
    RelayStatus status();
    boolean is_connected();
};

// Bitcoin & BDK

enum Network {
    "Bitcoin",
    "Testnet",
    "Signet",
    "Regtest",
};

enum WordCount {
    "W12",
    "W18",
    "W24",
};

interface OutPoint {
    string txid();
    u32 vout();
};

interface TxIn {
  OutPoint previous_output();
};

interface TxOut {
  u64 value();
  [Throws=FFIError]
  string address(Network network);
};

interface Transaction {
  string txid();
  u64 weight();
  u64 size();
  u64 vsize();
  boolean is_explicitly_rbf();
  boolean is_lock_time_enabled();
  i32 version();
  u32 lock_time();
  sequence<TxIn> inputs();
  sequence<TxOut> outputs();
};

interface Utxo {
    OutPoint outpoint();
    u64 value();
    boolean is_spent();
    string? label();
};

interface GetAddress {
    string address();
    string? label();
};

interface Balance {
    u64 get_spendable();
    u64 get_total();
};

interface TransactionDetails {
  u64? fee();
  u64 received();
  u64 sent();
  i64 total();
  string txid();
  BlockTime? confirmation_time();
  Transaction? transaction();
};

interface GetTransaction {
    TransactionDetails tx();
    string? label();
};

interface BlockTime {
  u32 height();
  Timestamp timestamp();
};

[Enum]
interface AddressIndex {
  New();
  LastUnused();
  Peek(u32 index);
  Reset(u32 index);
};


// Coinstr

interface KeychainSeed {
    string mnemonic();
    string? passphrase();
};

interface Policy {
    string name();
    string description();
    string descriptor();
};

interface GetPolicy {
    EventId policy_id();
    Policy policy();
    Timestamp? last_sync();
};

enum SignerType {
    "Seed",
    "Hardware",
    "AirGap",
};

interface Signer {
    string name();
    string fingerprint();
    string descriptor();
    SignerType signer_type();
    string display();
};

interface Amount {
    [Name=custom]
    constructor(u64 amount);
    [Name=max]
    constructor();
};

[Enum]
interface Proposal {
  Spending(string descriptor, string to_address, u64 amount, string description, string psbt);
  ProofOfReserve(string descriptor, string message, string psbt);
};

interface GetProposal {
    EventId proposal_id();
    EventId policy_id();
    Proposal proposal();
};

[Enum]
interface ApprovedProposal {
  Spending(string psbt);
  ProofOfReserve(string psbt);
};

[Enum]
interface CompletedProposal {
  Spending(string txid, string description);
  ProofOfReserve(string descriptor, string message, string psbt);
};

interface GetCompletedProposal {
    EventId completed_proposal_id();
    EventId policy_id();
    CompletedProposal completed_proposal();
};

interface Approval {
    PublicKey public_key();
    Timestamp timestamp();
};

interface NostrConnectURI {
    [Throws=FFIError, Name=from_string]
    constructor(string uri);
    PublicKey public_key();
    string relay_url();
    string name();
    string? url();
    string? description();
};

dictionary NostrConnectSession {
    NostrConnectURI uri;
    u64 timestamp;
};

interface NostrConnectRequest {
    EventId event_id();
    PublicKey app_public_key();
    string message();
    u64 timestamp();
    boolean approved();
};

interface Config {
    [Throws=FFIError]
    void save();
    void set_electrum_endpoint(string endpoint);
    [Throws=FFIError]
    string electrum_endpoint();
    [Throws=FFIError]
    void set_block_explorer(string url);
    [Throws=FFIError]
    string block_explorer();
};

interface Coinstr {
    [Throws=FFIError, Name=open]
    constructor(string base_path, string name, string password, Network network);
    [Throws=FFIError, Name=generate]
    constructor(string base_path, string name, string password, WordCount word_count, string? passphrase, Network network);
    [Throws=FFIError, Name=restore]
    constructor(string base_path, string name, string password, string mnemonic, string? passphrase, Network network);

    string? name();
    [Throws=FFIError]
    void save();
    boolean check_password(string password);
    [Throws=FFIError]
    void rename(string new_name);
    [Throws=FFIError]
    void change_password(string new_password);
    [Throws=FFIError]
    void wipe(string password);
    void start();
    [Throws=FFIError]
    void stop();
    [Throws=FFIError]
    void clear_cache();

    KeychainSeed seed();
    Keys keys();

    Network network();

    [Throws=FFIError]
    void add_relay(string url);
    sequence<Relay> relays();
    sequence<string> default_relays();
    [Throws=FFIError]
    void remove_relay(string url);
    [Throws=FFIError]
    void shutdown();
    Config config();
    u32 block_height();

    [Throws=FFIError]
    void set_metadata(string json);
    [Throws=FFIError]
    Metadata get_profile();
    [Throws=FFIError]
    record<DOMString, Metadata> get_contacts();
    [Throws=FFIError]
    void add_contact(PublicKey public_key);
    [Throws=FFIError]
    void remove_contact(PublicKey public_key);

    [Throws=FFIError]
    GetPolicy get_policy_by_id(EventId policy_id);  
    [Throws=FFIError]
    GetProposal get_proposal_by_id(EventId proposal_id);  
    [Throws=FFIError]
    GetCompletedProposal get_completed_proposal_by_id(EventId completed_proposal_id);
    [Throws=FFIError]
    Signer get_signer_by_id(EventId signer_id); 

    [Throws=FFIError]
    void delete_policy_by_id(EventId policy_id);  
    [Throws=FFIError]
    void delete_proposal_by_id(EventId proposal_id);  
    [Throws=FFIError]
    void delete_completed_proposal_by_id(EventId completed_proposal_id);
    [Throws=FFIError]
    void delete_signer_by_id(EventId signer_id); 

    [Throws=FFIError]
    sequence<GetPolicy> get_policies();
    [Throws=FFIError]
    sequence<GetProposal> get_proposals();
    [Throws=FFIError]
    sequence<GetProposal> get_proposals_by_policy_id(EventId policy_id);
    [Throws=FFIError]
    boolean is_proposal_signed(EventId proposal_id);
    [Throws=FFIError]
    record<DOMString, Approval> get_approvals_by_proposal_id(EventId proposal_id);
    [Throws=FFIError]
    sequence<GetCompletedProposal> get_completed_proposals();

    [Throws=FFIError]
    EventId save_policy(string name, string description, string descriptor, sequence<PublicKey> public_keys);
    [Throws=FFIError]
    GetProposal spend(EventId policy_id, string to_address, Amount amount, string description, u8 target_blocks, sequence<OutPoint>? utxos);
    [Throws=FFIError]
    GetProposal self_transfer(EventId from_policy_id, EventId to_policy_id, Amount amount, u8 target_blocks, sequence<OutPoint>? utxos);   
    [Throws=FFIError]
    EventId approve(EventId proposal_id);
    [Throws=FFIError]
    EventId approve_with_signed_psbt(EventId proposal_id, string signed_psbt);
    [Throws=FFIError]
    void revoke_approval(EventId approval_id);
    [Throws=FFIError]
    CompletedProposal finalize(EventId proposal_id);
    [Throws=FFIError]
    EventId new_proof_proposal(EventId policy_id, string message);

    [Throws=FFIError]
    boolean coinstr_signer_exists();
    [Throws=FFIError]
    EventId save_coinstr_signer();
    [Throws=FFIError]
    record<DOMString, Signer> get_signers();

    Balance? get_balance(EventId policy_id);
    [Throws=FFIError]
    sequence<GetTransaction> get_txs(EventId policy_id);
    [Throws=FFIError]
    GetTransaction get_tx(EventId policy_id, string txid);
    [Throws=FFIError]
    sequence<Utxo> get_utxos(EventId policy_id);
    [Throws=FFIError]
    Balance get_total_balance();
    [Throws=FFIError]
    sequence<GetTransaction> get_all_txs();
    [Throws=FFIError]
    GetAddress get_address(EventId policy_id, AddressIndex index);
    [Throws=FFIError]
    GetAddress get_last_unused_address(EventId policy_id);

    [Throws=FFIError]
    void rebroadcast_all_events();
    [Throws=FFIError]
    void republish_shared_key_for_policy(EventId policy_id);
    
    [Throws=FFIError]
    void new_nostr_connect_session(NostrConnectURI uri);
    [Throws=FFIError]
    sequence<NostrConnectSession> get_nostr_connect_sessions();
    [Throws=FFIError]
    void disconnect_nostr_connect_session(PublicKey app_public_key);
    [Throws=FFIError]
    sequence<NostrConnectRequest> get_nostr_connect_requests(boolean approved);
    [Throws=FFIError]
    void approve_nostr_connect_request(EventId event_id);
    [Throws=FFIError]
    void reject_nostr_connect_request(EventId event_id);
    [Throws=FFIError]
    void auto_approve_nostr_connect_requests(PublicKey app_public_key, duration duration);

    [Self=ByArc]
    AbortHandle handle_sync(SyncHandler handler);
};

[Enum]
interface EventHandled {
    EHSharedKey(string event_id);
    EHPolicy(string policy_id);
    EHProposal(string proposal_id);
    EHApproval(string proposal_id);
    EHCompletedProposal(string completed_proposal_id);
    EHSigner(string signer_id);
    EHMySharedSigner(string my_shared_signer_id);
    EHSharedSigner(string shared_signer_id);
    EHContacts();
    EHMetadata(string public_key);
    EHNostrConnectRequest(string request_id);
    EHLabel();
    EHEventDeletion();
};

[Enum]
interface Message {
  EvH(EventHandled event);
  WalletSyncCompleted(string policy_id);
  BlockHeightUpdated();
  Null();
};

callback interface SyncHandler {
    void handle(Message msg);
};
