// Copyright (c) 2023 Coinstr
// Distributed under the MIT software license

namespace coinstr_sdk {
    [Throws=FFIError]
    void init_desktop_logger(string base_path, Network network);
    void init_mobile_logger();
    string git_hash_version();
    [Throws=FFIError]
    sequence<string> get_keychains_list(string base_path, Network network);
};

[Error]
interface FFIError {
    Generic(string err);
};

interface AbortHandle {
    void abort();
    boolean is_aborted();
};

// Nostr FFI

interface Timestamp {
    [Name=now]
    constructor();
    [Name=from_secs]
    constructor(u64 secs);
    u64 as_secs();
    string to_human_datetime();
};

interface SecretKey {
    [Throws=FFIError, Name=from_hex]
    constructor(string hex);
    [Throws=FFIError, Name=from_bech32]
    constructor(string pk);
    string to_hex();
    [Throws=FFIError]
    string to_bech32();
};

interface PublicKey {
    [Throws=FFIError, Name=from_hex]
    constructor(string hex);
    [Throws=FFIError, Name=from_bech32]
    constructor(string pk);
    [Throws=FFIError, Name=from_nostr_uri]
    constructor(string uri);
    string to_hex();
    [Throws=FFIError]
    string to_bech32();
    [Throws=FFIError]
    string to_nostr_uri();
};

interface Keys {
    constructor(SecretKey sk);
    [Name=from_public_key]
    constructor(PublicKey pk);
    [Throws=FFIError, Name=from_sk_str]
    constructor(string sk);
    [Throws=FFIError, Name=from_pk_str]
    constructor(string pk);
    [Name=generate]
    constructor();
    [Throws=FFIError, Name=vanity]
    constructor(sequence<string> prefixes, boolean bech32, u8 num_cores);
    [Throws=FFIError, Name=from_mnemonic]
    constructor(string mnemonic, optional string? passphrase = null);
    PublicKey public_key();
    [Throws=FFIError]
    SecretKey secret_key();
};

interface EventId {
    [Throws=FFIError]
    constructor(PublicKey pubkey, Timestamp created_at, u64 kind, sequence<sequence<string>> tags, string content);
    [Throws=FFIError, Name=from_bytes]
    constructor(sequence<u8> bytes);
    [Throws=FFIError, Name=from_hex]
    constructor(string hex);
    [Throws=FFIError, Name=from_bech32]
    constructor(string id);
    [Throws=FFIError, Name=from_nostr_uri]
    constructor(string uri);
    sequence<u8> as_bytes();
    string to_hex();
    [Throws=FFIError]
    string to_bech32();
    [Throws=FFIError]
    string to_nostr_uri();
};

interface Metadata {
    constructor();

    [Throws=FFIError, Name=from_json]
    constructor(string json);
    string as_json();

    [Self=ByArc]
    Metadata set_name(string name);
    [Self=ByArc]
    Metadata set_display_name(string display_name);
    [Self=ByArc]
    Metadata set_about(string about);
    [Throws=FFIError, Self=ByArc]
    Metadata set_website(string website);
    [Throws=FFIError, Self=ByArc]
    Metadata set_picture(string picture);
    [Throws=FFIError, Self=ByArc]
    Metadata set_banner(string banner);
    [Self=ByArc]
    Metadata set_nip05(string nip05);
    [Self=ByArc]
    Metadata set_lud06(string lud06);
    [Self=ByArc]
    Metadata set_lud16(string lud16);

    string? get_name();
    string? get_display_name();
    string? get_about();
    string? get_website();
    string? get_picture();
    string? get_banner();
    string? get_nip05();
    string? get_lud06();
    string? get_lud16();
};

interface RelayInformationDocument {
    [Throws=FFIError, Name=get]
    constructor(string url, string? proxy);
    string? name();
    string? description();
    string? pubkey();
    string? contact();
    sequence<u16>? supported_nips();
    string? software();
    string? version();
};

enum RelayStatus {
    "Initialized",
    "Connected",
    "Connecting",
    "Disconnected",
    "Stopped",
    "Terminated",
};

interface RelayConnectionStats {
    u64 attempts();
    u64 success();
    u64 bytes_sent();
    u64 bytes_received();
    duration? latency();
    Timestamp connected_at();
};

interface Relay {
    string url();
    string? proxy();
    RelayStatus status();
    boolean is_connected();
    RelayInformationDocument document();
    RelayConnectionStats stats();
    u64 queue();
};

// Bitcoin & BDK

enum Network {
    "Bitcoin",
    "Testnet",
    "Signet",
    "Regtest",
};

enum WordCount {
    "W12",
    "W18",
    "W24",
};

interface OutPoint {
    string txid();
    u32 vout();
};

interface TxIn {
  OutPoint previous_output();
};

interface TxOut {
  u64 value();
  [Throws=FFIError]
  string address(Network network);
};

interface Transaction {
  string txid();
  u64 weight();
  u64 size();
  u64 vsize();
  boolean is_explicitly_rbf();
  boolean is_lock_time_enabled();
  i32 version();
  u32 lock_time();
  sequence<TxIn> inputs();
  sequence<TxOut> outputs();
};

interface Utxo {
    OutPoint outpoint();
    u64 value();
    boolean is_spent();
    string? label();
};

interface GetAddress {
    string address();
    string? label();
};

interface Balance {
    u64 get_spendable();
    u64 get_total();
};

interface TransactionDetails {
  u64? fee();
  u64 received();
  u64 sent();
  i64 total();
  string txid();
  BlockTime? confirmation_time();
  Transaction transaction();
};

interface GetTransaction {
    EventId policy_id();
    TransactionDetails tx();
    string? label();
};

interface BlockTime {
  u32 height();
  Timestamp timestamp();
};

[Enum]
interface AddressIndex {
  New();
  LastUnused();
  Peek(u32 index);
};


// Coinstr

interface KeychainSeed {
    string mnemonic();
    string? passphrase();
};

interface Policy {
    string name();
    string description();
    string descriptor();
    [Throws=FFIError]
    string satisfiable_item(Network network);
    boolean has_timelock();
    [Throws=FFIError]
    record<DOMString, sequence<string>>? selectable_conditions(Network network);
    [Throws=FFIError]
    PolicyTemplateType? template_match(Network network);
};

interface GetPolicy {
    EventId policy_id();
    Policy policy();
    Timestamp? last_sync();
};

enum SignerType {
    "Seed",
    "Hardware",
    "AirGap",
};

interface Signer {
    string name();
    string fingerprint();
    [Throws=FFIError]
    Descriptor descriptor();
    SignerType signer_type();
    string display();
};

interface GetSigner {
    EventId signer_id();
    Signer signer();
};

interface SharedSigner {
    string fingerprint();
    [Throws=FFIError]
    Descriptor descriptor();
};

interface GetSharedSigner {
    EventId shared_signer_id();
    PublicKey owner_public_key();
    SharedSigner shared_signer();
};

interface Descriptor {
    [Throws=FFIError, Name=from_str]
    constructor(string str);
    string to_str();
};

interface RelativeLockTime {
    [Name=from_blocks]
    constructor(u16 blocks);
};

interface AbsoluteLockTime {
    [Throws=FFIError, Name=from_height]
    constructor(u32 height);
    [Throws=FFIError, Name=from_timestamp]
    constructor(u32 timestamp);
};

interface RecoveryTemplate {
    [Name=social_recovery]
    constructor(u64 threshold, sequence<Descriptor> keys, RelativeLockTime older);
    [Name=inheritance]
    constructor(u64 threshold, sequence<Descriptor> keys, AbsoluteLockTime after);
};

enum PolicyTemplateType {
    "Multisig",
    "SocialRecovery",
    "Inheritance",
    "Hold",
};

interface PolicyTemplate {
    [Name=multisig]
    constructor(u64 threshold, sequence<Descriptor> keys);
    [Name=recovery]
    constructor(Descriptor my_key, RecoveryTemplate recovery);
    [Name=hold]
    constructor(Descriptor my_key, RelativeLockTime older);
};

interface Amount {
    [Name=custom]
    constructor(u64 amount);
    [Name=max]
    constructor();
};

[Enum]
interface Proposal {
  Spending(string descriptor, string to_address, u64 amount, string description, string psbt);
  ProofOfReserve(string descriptor, string message, string psbt);
};

interface GetProposal {
    EventId proposal_id();
    EventId policy_id();
    Proposal proposal();
    boolean is_signed();
};

[Enum]
interface ApprovedProposal {
  Spending(string psbt);
  ProofOfReserve(string psbt);
};

[Enum]
interface CompletedProposal {
  Spending(string txid, string description);
  ProofOfReserve(string descriptor, string message, string psbt);
};

interface GetCompletedProposal {
    EventId completed_proposal_id();
    EventId policy_id();
    CompletedProposal completed_proposal();
};

interface GetApproval {
    EventId approval_id();
    PublicKey public_key();
    ApprovedProposal approved_proposal();
    Timestamp timestamp();
};

interface NostrConnectURI {
    [Throws=FFIError, Name=from_string]
    constructor(string uri);
    PublicKey public_key();
    string relay_url();
    string name();
    string? url();
    string? description();
};

dictionary NostrConnectSession {
    NostrConnectURI uri;
    u64 timestamp;
};

interface NostrConnectRequest {
    EventId event_id();
    PublicKey app_public_key();
    string message();
    u64 timestamp();
    boolean approved();
};

interface GetContact {
    PublicKey public_key();
    Metadata metadata();
};

interface Config {
    [Throws=FFIError]
    void save();
    void set_electrum_endpoint(string endpoint);
    [Throws=FFIError]
    string electrum_endpoint();
    [Throws=FFIError]
    void set_block_explorer(string url);
    [Throws=FFIError]
    string block_explorer();
};

interface Coinstr {
    [Throws=FFIError, Name=open]
    constructor(string base_path, string name, string password, Network network);
    [Throws=FFIError, Name=generate]
    constructor(string base_path, string name, string password, string confirm_password, WordCount word_count, string? passphrase, Network network);
    [Throws=FFIError, Name=restore]
    constructor(string base_path, string name, string password, string confirm_password, string mnemonic, string? passphrase, Network network);

    string? name();
    [Throws=FFIError]
    void save();
    [Throws=FFIError]
    boolean check_password(string password);
    [Throws=FFIError]
    void rename(string new_name);
    [Throws=FFIError]
    void change_password(string password, string new_password, string confirm_password);
    [Throws=FFIError]
    void wipe(string password);
    void start();
    [Throws=FFIError]
    void stop();
    [Throws=FFIError]
    void clear_cache();

    KeychainSeed seed();
    Keys keys();

    Network network();

    [Throws=FFIError]
    void add_relay(string url);
    sequence<Relay> relays();
    sequence<string> default_relays();
    [Throws=FFIError]
    void remove_relay(string url);
    [Throws=FFIError]
    void shutdown();
    Config config();
    u32 block_height();

    [Throws=FFIError]
    void set_metadata(Metadata metadata);
    [Throws=FFIError]
    Metadata get_profile();
    [Throws=FFIError]
    sequence<GetContact> get_contacts();
    [Throws=FFIError]
    void add_contact(PublicKey public_key);
    [Throws=FFIError]
    void remove_contact(PublicKey public_key);

    [Throws=FFIError]
    GetPolicy get_policy_by_id(EventId policy_id);  
    [Throws=FFIError]
    GetProposal get_proposal_by_id(EventId proposal_id);  
    [Throws=FFIError]
    GetCompletedProposal get_completed_proposal_by_id(EventId completed_proposal_id);
    [Throws=FFIError]
    Signer get_signer_by_id(EventId signer_id); 

    [Throws=FFIError]
    void delete_policy_by_id(EventId policy_id);  
    [Throws=FFIError]
    void delete_proposal_by_id(EventId proposal_id);  
    [Throws=FFIError]
    void delete_completed_proposal_by_id(EventId completed_proposal_id);
    [Throws=FFIError]
    void delete_signer_by_id(EventId signer_id); 

    [Throws=FFIError]
    sequence<GetPolicy> get_policies();
    [Throws=FFIError]
    sequence<GetProposal> get_proposals();
    [Throws=FFIError]
    sequence<GetProposal> get_proposals_by_policy_id(EventId policy_id);
    [Throws=FFIError]
    sequence<GetApproval> get_approvals_by_proposal_id(EventId proposal_id);
    [Throws=FFIError]
    sequence<GetCompletedProposal> get_completed_proposals();

    [Throws=FFIError]
    EventId save_policy(string name, string description, string descriptor, sequence<PublicKey> public_keys);
    [Throws=FFIError]
    EventId save_policy_from_template(string name, string description, PolicyTemplate template, sequence<PublicKey> public_keys);
    [Throws=FFIError]
    GetProposal spend(EventId policy_id, string to_address, Amount amount, string description, u8 target_blocks, sequence<OutPoint>? utxos, record<DOMString, sequence<u64>>? policy_path, boolean skip_frozen_utxos);
    [Throws=FFIError]
    GetProposal self_transfer(EventId from_policy_id, EventId to_policy_id, Amount amount, u8 target_blocks, sequence<OutPoint>? utxos, record<DOMString, sequence<u64>>? policy_path, boolean skip_frozen_utxos);   
    [Throws=FFIError]
    EventId approve(EventId proposal_id);
    [Throws=FFIError]
    EventId approve_with_signed_psbt(EventId proposal_id, string signed_psbt);
    [Throws=FFIError]
    void revoke_approval(EventId approval_id);
    [Throws=FFIError]
    CompletedProposal finalize(EventId proposal_id);
    [Throws=FFIError]
    EventId new_proof_proposal(EventId policy_id, string message);

    [Throws=FFIError]
    boolean coinstr_signer_exists();
    [Throws=FFIError]
    EventId save_coinstr_signer();
    [Throws=FFIError]
    sequence<GetSigner> get_signers();
    [Throws=FFIError]
    EventId share_signer(EventId signer_id, PublicKey public_key);
    [Throws=FFIError]
    void share_signer_to_multiple_public_keys(EventId signer_id, sequence<PublicKey> public_keys);
    [Throws=FFIError]
    void revoke_all_shared_signers();
    [Throws=FFIError]
    void revoke_shared_signer(EventId shared_signer_id);
    [Throws=FFIError]
    sequence<GetSharedSigner> get_shared_signers();
    [Throws=FFIError]
    sequence<PublicKey> get_shared_signers_public_keys(boolean include_contacts);
    [Throws=FFIError]
    sequence<GetSharedSigner> get_shared_signers_by_public_key(PublicKey public_key);

    Balance? get_balance(EventId policy_id);
    [Throws=FFIError]
    sequence<GetTransaction> get_txs(EventId policy_id);
    [Throws=FFIError]
    GetTransaction get_tx(EventId policy_id, string txid);
    [Throws=FFIError]
    sequence<Utxo> get_utxos(EventId policy_id);
    [Throws=FFIError]
    Balance get_total_balance();
    [Throws=FFIError]
    sequence<GetTransaction> get_all_txs();
    [Throws=FFIError]
    GetAddress get_address(EventId policy_id, AddressIndex index);
    [Throws=FFIError]
    GetAddress get_last_unused_address(EventId policy_id);

    [Throws=FFIError]
    void rebroadcast_all_events();
    [Throws=FFIError]
    void republish_shared_key_for_policy(EventId policy_id);
    
    [Throws=FFIError]
    void new_nostr_connect_session(NostrConnectURI uri);
    [Throws=FFIError]
    sequence<NostrConnectSession> get_nostr_connect_sessions();
    [Throws=FFIError]
    void disconnect_nostr_connect_session(PublicKey app_public_key);
    [Throws=FFIError]
    sequence<NostrConnectRequest> get_nostr_connect_requests(boolean approved);
    [Throws=FFIError]
    void approve_nostr_connect_request(EventId event_id);
    [Throws=FFIError]
    void reject_nostr_connect_request(EventId event_id);
    void auto_approve_nostr_connect_requests(PublicKey app_public_key, duration duration);

    [Self=ByArc]
    AbortHandle handle_sync(SyncHandler handler);
};

[Enum]
interface EventHandled {
    EHSharedKey(string event_id);
    EHPolicy(string policy_id);
    EHProposal(string proposal_id);
    EHApproval(string proposal_id);
    EHCompletedProposal(string completed_proposal_id);
    EHSigner(string signer_id);
    EHMySharedSigner(string my_shared_signer_id);
    EHSharedSigner(string shared_signer_id);
    EHContacts();
    EHMetadata(string public_key);
    EHNostrConnectRequest(string request_id);
    EHLabel();
    EHEventDeletion();
};

[Enum]
interface Message {
  EvH(EventHandled event);
  WalletSyncCompleted(string policy_id);
  BlockHeightUpdated();
  Null();
};

callback interface SyncHandler {
    void handle(Message msg);
};
