[Enum]
interface PolicyPath {
    Single(PolicyPathSelector pp);
    Multiple(sequence<PolicyPathSigner> list);
    None();
};

dictionary PolicyPathSigner {
    Signer signer;
    PolicyPathSelector? policy_path;
};

[Enum]
interface PolicyPathSelector {
    Complete(record<DOMString, sequence<u64>> path);
    Partial(record<DOMString, sequence<u64>> selected_path, record<DOMString, sequence<string>> missing_to_select);
};

interface Policy {
    string name();
    string description();
    string descriptor();
    [Throws=FFIError]
    string satisfiable_item(Network network);
    boolean has_timelock();
    [Throws=FFIError]
    record<DOMString, sequence<string>>? selectable_conditions(Network network);
    [Throws=FFIError]
    sequence<Signer> search_used_signers(sequence<Signer> signers);
    [Throws=FFIError]
    PolicyPathSelector? get_policy_path_from_signer(Signer signer, Network network);
    [Throws=FFIError]
    PolicyPath get_policy_paths_from_signers(sequence<Signer> signers, Network network);
    [Throws=FFIError]
    PolicyTemplateType? template_match(Network network);
};

interface GetPolicy {
    EventId policy_id();
    Policy policy();
    Balance balance();
    Timestamp? last_sync();
};

interface RelativeLockTime {
    [Name=from_blocks]
    constructor(u16 blocks);
};

interface AbsoluteLockTime {
    [Throws=FFIError, Name=from_height]
    constructor(u32 height);
    [Throws=FFIError, Name=from_timestamp]
    constructor(u32 timestamp);
};

interface Locktime {
    [Name=absolute]
    constructor(AbsoluteLockTime absolute);
    [Name=relative]
    constructor(RelativeLockTime relative);
};

interface DecayingTime {
    [Name=single]
    constructor(Locktime locktime);
    [Name=multiple]
    constructor(sequence<Locktime> locktimes);
};

interface RecoveryTemplate {
    constructor(u64 threshold, sequence<Descriptor> keys, Locktime locktime);
};

enum PolicyTemplateType {
    "Multisig",
    "Recovery",
    "Hold",
    "Decaying",
};

interface PolicyTemplate {
    [Name=multisig]
    constructor(u64 threshold, sequence<Descriptor> keys);
    [Name=recovery]
    constructor(Descriptor my_key, RecoveryTemplate recovery);
    [Name=hold]
    constructor(Descriptor my_key, Locktime locktime);
    [Name=decaying]
    constructor(u64 start_threshold, sequence<Descriptor> keys, DecayingTime time);
};