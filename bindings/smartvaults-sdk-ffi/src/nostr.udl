interface Timestamp {
    [Name=now]
    constructor();
    [Name=from_secs]
    constructor(u64 secs);
    u64 as_secs();
    string to_human_datetime();
};

interface SecretKey {
    [Throws=FFIError, Name=from_hex]
    constructor(string hex);
    [Throws=FFIError, Name=from_bech32]
    constructor(string sk);
    [Throws=FFIError, Name=from_bytes]
    constructor(sequence<u8> sk);
    string to_hex();
    [Throws=FFIError]
    string to_bech32();
};

interface PublicKey {
    [Throws=FFIError, Name=from_hex]
    constructor(string hex);
    [Throws=FFIError, Name=from_bech32]
    constructor(string pk);
    [Throws=FFIError, Name=from_bytes]
    constructor(sequence<u8> pk);
    [Throws=FFIError, Name=from_nostr_uri]
    constructor(string uri);
    string to_hex();
    [Throws=FFIError]
    string to_bech32();
    [Throws=FFIError]
    string to_nostr_uri();
};

interface Keys {
    constructor(SecretKey sk);
    [Name=from_public_key]
    constructor(PublicKey pk);
    [Throws=FFIError, Name=from_sk_str]
    constructor(string sk);
    [Throws=FFIError, Name=from_pk_str]
    constructor(string pk);
    [Name=generate]
    constructor();
    [Throws=FFIError, Name=vanity]
    constructor(sequence<string> prefixes, boolean bech32, u8 num_cores);
    [Throws=FFIError, Name=from_mnemonic]
    constructor(string mnemonic, optional string? passphrase = null);
    PublicKey public_key();
    [Throws=FFIError]
    SecretKey secret_key();
};

interface EventId {
    [Throws=FFIError]
    constructor(PublicKey pubkey, Timestamp created_at, u64 kind, sequence<sequence<string>> tags, string content);
    [Throws=FFIError, Name=from_bytes]
    constructor(sequence<u8> bytes);
    [Throws=FFIError, Name=from_hex]
    constructor(string hex);
    [Throws=FFIError, Name=from_bech32]
    constructor(string id);
    [Throws=FFIError, Name=from_nostr_uri]
    constructor(string uri);
    sequence<u8> as_bytes();
    string to_hex();
    [Throws=FFIError]
    string to_bech32();
    [Throws=FFIError]
    string to_nostr_uri();
};

interface Metadata {
    constructor();

    [Throws=FFIError, Name=from_json]
    constructor(string json);
    string as_json();

    [Self=ByArc]
    Metadata set_name(string name);
    [Self=ByArc]
    Metadata set_display_name(string display_name);
    [Self=ByArc]
    Metadata set_about(string about);
    [Throws=FFIError, Self=ByArc]
    Metadata set_website(string website);
    [Throws=FFIError, Self=ByArc]
    Metadata set_picture(string picture);
    [Throws=FFIError, Self=ByArc]
    Metadata set_banner(string banner);
    [Self=ByArc]
    Metadata set_nip05(string nip05);
    [Self=ByArc]
    Metadata set_lud06(string lud06);
    [Self=ByArc]
    Metadata set_lud16(string lud16);
    [Self=ByArc]
    Metadata set_custom_field(string key, string value);

    string? get_name();
    string? get_display_name();
    string? get_about();
    string? get_website();
    string? get_picture();
    string? get_banner();
    string? get_nip05();
    string? get_lud06();
    string? get_lud16();
    string? get_custom_field(string key);
};

interface RelayInformationDocument {
    [Throws=FFIError, Name=get]
    constructor(string url, string? proxy);
    string? name();
    string? description();
    string? pubkey();
    string? contact();
    sequence<u16>? supported_nips();
    string? software();
    string? version();
};

interface NostrConnectURI {
    [Throws=FFIError, Name=from_string]
    constructor(string uri);
    PublicKey public_key();
    string relay_url();
    string name();
    string? url();
    string? description();
};